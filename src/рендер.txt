raylib в целом позволяет поворачивать, растягивать и сжимать текстуры
надо как-то по оптимальнее всё инкапсулировать чтоб как дебилы каждый раз не вызывать BeginДерьмо() EndДерьмо()

допустим, что всё, что находится на карте (возможно ещё и UI, healthbar там например), это objects
создадим класс ObjectRenderer, экземпляр которого будет у каждого объекта
также каждому объекту дадим метод render(), который отвечает за отрисовку объекта
ObjectRenderer будет хранить в себе (допустим в HashMap'ах) все текстуры и анимации (о них позже), связанные с объектом
(например для игрока это будут анимации движения, полёта, текстуры для падения, стояния на месте и т.п.)

пример списка методов ObjectRenderer:
renderer() - конструктор, пока хз что ему понадобиться, позиция игрока, мб ещё что-то
renderer.addTexture("путь/до/текстуры.png")
renderer.addAnimation("путь/до/папки/с/картинками", speed) - пожалуй сам вызовет конструктор анимации (см ниже)
renderer.getTexture("name") - возвращает текстуру из HashMap'a
renderer.setTexture(texture) - ставит, какую текстуру отрисовать на объект (без говна вроде позиции, цвета, сам решит вопрос blending'а)
renderer.setRotation(0..359) - установит градус поворота перед отрисовкой
renderer.addShader(shader) - добавит шейдер к объекту (нужен кастомный класс Shader)
renderer.update() - ну собс-на рендер текстур и шейдеров, апдейт анимаций

теперь его соседи:
Animation:
    animation("путь/до/папки/с/картинками", speed) - конструктор (нужно что-то придумать с загрузкой файлов, а то для 100 снарядов грузить по 5 картинок с HDD это смэрть, мб что-то со static)
                                                     конструктор загрузит текстуры из картинок и добавит их в массив, а скорость сохранит в переменную
    animation.getCurrentTexture() - возвращает картинку, которую сейчас нужно отобразить
    animation.update() - подумает, какую картинку вернуть в следующий раз
поскольку анимации не меняют картинку каждый кадр, там должен быть какой то счётчик времени / кадров, чтобы реже менять их (speed в помощь)

Инкапсулировать Shader нужно, поскольку обычно они рисуются не на самих объектах, а на по большей части прозрачных прямоугольниках
То есть поверх объекта ещё нужно будет рисовать отдельную фигуру, разбираться как она будет блендиться
инкапсулировать set/get внутренних значений, установку blending mode'а (через Enum) 
и в конце будет опять таки метод shader.draw() (думаю вызывать в render.update())